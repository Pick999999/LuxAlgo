<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMC Indicator Demo - LightweightCharts</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            min-height: 100vh;
            color: #e4e4e7;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 30px 0;
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #a1a1aa;
            font-size: 1.1rem;
        }

        .chart-container {
            background: rgba(26, 26, 46, 0.8);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        #chart {
            width: 100%;
            height: 500px;
            border-radius: 8px;
            overflow: hidden;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 0.95rem;
        }

        .control-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .control-group input[type="number"] {
            width: 80px;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #e4e4e7;
            font-size: 0.9rem;
        }

        .control-group input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-card h3 {
            font-size: 1rem;
            color: #a1a1aa;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .info-value.bullish {
            color: #089981;
        }

        .info-value.bearish {
            color: #F23645;
        }

        .info-value.neutral {
            color: #787B86;
        }

        .badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            margin: 2px;
        }

        .badge.bullish {
            background: rgba(8, 153, 129, 0.2);
            color: #089981;
        }

        .badge.bearish {
            background: rgba(242, 54, 69, 0.2);
            color: #F23645;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 12px;
            border-radius: 3px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            #chart {
                height: 350px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>ðŸŽ¯ Smart Money Concepts</h1>
            <p class="subtitle">Advanced Market Structure Analysis for LightweightCharts</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showSwingPoints" checked>
                    Swing Points (HH/HL/LH/LL)
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showStructures" checked>
                    Structure (CHoCH/BOS)
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showOrderBlocks" checked>
                    Order Blocks
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showFVG" checked>
                    Fair Value Gaps
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showEqualHL" checked>
                    Equal Highs/Lows
                </label>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showPremiumDiscount">
                    Premium/Discount Zones
                </label>
            </div>
            <div class="control-group">
                <label>
                    Swing Length:
                    <input type="number" id="swingLength" value="50" min="10" max="100">
                </label>
            </div>
            <div class="control-group">
                <button class="btn btn-primary" id="updateBtn">Update Chart</button>
            </div>
        </div>

        <div class="chart-container">
            <div id="chart"></div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #089981;"></div>
                    <span>Bullish Structure</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #F23645;"></div>
                    <span>Bearish Structure</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(49, 121, 245, 0.5);"></div>
                    <span>Bullish Order Block</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(247, 124, 128, 0.5);"></div>
                    <span>Bearish Order Block</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(0, 255, 104, 0.5);"></div>
                    <span>Bullish FVG</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: rgba(255, 0, 8, 0.5);"></div>
                    <span>Bearish FVG</span>
                </div>
            </div>
        </div>

        <div class="info-panel">
            <div class="info-card">
                <h3>Swing Trend</h3>
                <div class="info-value" id="swingTrend">-</div>
            </div>
            <div class="info-card">
                <h3>Internal Trend</h3>
                <div class="info-value" id="internalTrend">-</div>
            </div>
            <div class="info-card">
                <h3>Active Order Blocks</h3>
                <div id="orderBlockStats">-</div>
            </div>
            <div class="info-card">
                <h3>Recent Structures</h3>
                <div id="structureStats">-</div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // SMC INDICATOR CLASS (Embedded)
        // ============================================================
        const BULLISH = 1;
        const BEARISH = -1;
        const BULLISH_LEG = 1;
        const BEARISH_LEG = 0;

        class SMCIndicator {
            constructor(config = {}) {
                this.config = {
                    swingLength: config.swingLength || 50,
                    internalLength: config.internalLength || 5,
                    showInternalStructure: config.showInternalStructure !== false,
                    showSwingStructure: config.showSwingStructure !== false,
                    showOrderBlocks: config.showOrderBlocks !== false,
                    maxOrderBlocks: config.maxOrderBlocks || 5,
                    showFVG: config.showFVG !== false,
                    showEqualHL: config.showEqualHL !== false,
                    equalHLLength: config.equalHLLength || 3,
                    equalHLThreshold: config.equalHLThreshold || 0.1,
                    showPremiumDiscount: config.showPremiumDiscount !== false,
                    orderBlockFilter: config.orderBlockFilter || 'atr',
                    orderBlockMitigation: config.orderBlockMitigation || 'highlow',
                    atrPeriod: config.atrPeriod || 200
                };
                this._reset();
            }

            _reset() {
                this.swingHigh = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };
                this.swingLow = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };
                this.internalHigh = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };
                this.internalLow = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };
                this.equalHigh = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };
                this.equalLow = { currentLevel: null, lastLevel: null, crossed: false, time: null, index: null };

                this.swingTrend = 0;
                this.internalTrend = 0;

                this.trailing = {
                    top: null, bottom: null, topTime: null, bottomTime: null, barTime: null, barIndex: null
                };

                this.structures = [];
                this.swingPoints = [];
                this.orderBlocks = [];
                this.fairValueGaps = [];
                this.equalHighsLows = [];
                this.strongWeakLevels = [];
                this.premiumDiscountZones = [];

                this.swingLeg = 0;
                this.internalLeg = 0;

                this.data = [];
                this.highs = [];
                this.lows = [];
                this.parsedHighs = [];
                this.parsedLows = [];
                this.atrValues = [];
            }

            _calculateATR(data, period) {
                const tr = [];
                const atr = [];

                for (let i = 0; i < data.length; i++) {
                    if (i === 0) {
                        tr.push(data[i].high - data[i].low);
                    } else {
                        const highLow = data[i].high - data[i].low;
                        const highPrevClose = Math.abs(data[i].high - data[i - 1].close);
                        const lowPrevClose = Math.abs(data[i].low - data[i - 1].close);
                        tr.push(Math.max(highLow, highPrevClose, lowPrevClose));
                    }

                    if (i < period - 1) {
                        atr.push(null);
                    } else if (i === period - 1) {
                        const sum = tr.slice(0, period).reduce((a, b) => a + b, 0);
                        atr.push(sum / period);
                    } else {
                        atr.push((atr[i - 1] * (period - 1) + tr[i]) / period);
                    }
                }

                return atr;
            }

            _highest(arr, start, end) {
                let max = -Infinity;
                for (let i = start; i <= end && i < arr.length; i++) {
                    if (arr[i] > max) max = arr[i];
                }
                return max;
            }

            _lowest(arr, start, end) {
                let min = Infinity;
                for (let i = start; i <= end && i < arr.length; i++) {
                    if (arr[i] < min) min = arr[i];
                }
                return min;
            }

            _indexOfMax(arr, start, end) {
                let maxIdx = start;
                let max = arr[start];
                for (let i = start; i <= end && i < arr.length; i++) {
                    if (arr[i] > max) {
                        max = arr[i];
                        maxIdx = i;
                    }
                }
                return maxIdx;
            }

            _indexOfMin(arr, start, end) {
                let minIdx = start;
                let min = arr[start];
                for (let i = start; i <= end && i < arr.length; i++) {
                    if (arr[i] < min) {
                        min = arr[i];
                        minIdx = i;
                    }
                }
                return minIdx;
            }

            _getLeg(index, size, prevLeg) {
                if (index < size) return prevLeg;

                const currentHigh = this.highs[index - size];
                const currentLow = this.lows[index - size];
                const highestRecent = this._highest(this.highs, index - size + 1, index);
                const lowestRecent = this._lowest(this.lows, index - size + 1, index);

                if (currentHigh > highestRecent) {
                    return BEARISH_LEG;
                } else if (currentLow < lowestRecent) {
                    return BULLISH_LEG;
                }

                return prevLeg;
            }

            _processStructure(index, size, isInternal) {
                const pivot = isInternal ? this.internalHigh : this.swingHigh;
                const pivotLow = isInternal ? this.internalLow : this.swingLow;
                const trend = isInternal ? this.internalTrend : this.swingTrend;
                const level = isInternal ? 'internal' : 'swing';

                const currentBar = this.data[index];
                const close = currentBar.close;

                if (pivot.currentLevel !== null && close > pivot.currentLevel && !pivot.crossed) {
                    const structureType = trend === BEARISH ? 'CHoCH' : 'BOS';

                    this.structures.push({
                        time: currentBar.time,
                        price: pivot.currentLevel,
                        type: structureType,
                        direction: 'bullish',
                        level: level,
                        startTime: pivot.time
                    });

                    pivot.crossed = true;
                    if (isInternal) {
                        this.internalTrend = BULLISH;
                    } else {
                        this.swingTrend = BULLISH;
                    }

                    if (this.config.showOrderBlocks) {
                        this._storeOrderBlock(pivot, index, BULLISH, isInternal);
                    }
                }

                if (pivotLow.currentLevel !== null && close < pivotLow.currentLevel && !pivotLow.crossed) {
                    const currentTrend = isInternal ? this.internalTrend : this.swingTrend;
                    const structureType = currentTrend === BULLISH ? 'CHoCH' : 'BOS';

                    this.structures.push({
                        time: currentBar.time,
                        price: pivotLow.currentLevel,
                        type: structureType,
                        direction: 'bearish',
                        level: level,
                        startTime: pivotLow.time
                    });

                    pivotLow.crossed = true;
                    if (isInternal) {
                        this.internalTrend = BEARISH;
                    } else {
                        this.swingTrend = BEARISH;
                    }

                    if (this.config.showOrderBlocks) {
                        this._storeOrderBlock(pivotLow, index, BEARISH, isInternal);
                    }
                }
            }

            _processSwingPoints(index, size, isInternal, forEqualHL = false) {
                if (index < size) return;

                const legRef = isInternal ? 'internalLeg' : 'swingLeg';
                const prevLeg = this[legRef];
                const newLeg = this._getLeg(index, size, prevLeg);

                if (newLeg !== prevLeg) {
                    this[legRef] = newLeg;

                    const pivotIndex = index - size;
                    const pivotBar = this.data[pivotIndex];
                    const atr = this.atrValues[pivotIndex] || 0;

                    if (newLeg === BULLISH_LEG) {
                        const pivot = forEqualHL ? this.equalLow : (isInternal ? this.internalLow : this.swingLow);
                        const pivotPrice = this.lows[pivotIndex];

                        if (forEqualHL && pivot.currentLevel !== null) {
                            if (Math.abs(pivot.currentLevel - pivotPrice) < this.config.equalHLThreshold * atr) {
                                this.equalHighsLows.push({
                                    time1: pivot.time,
                                    time2: pivotBar.time,
                                    price: pivotPrice,
                                    type: 'EQL'
                                });
                            }
                        }

                        if (!forEqualHL && !isInternal) {
                            const swingType = (pivot.lastLevel === null || pivotPrice < pivot.lastLevel) ? 'LL' : 'HL';
                            this.swingPoints.push({
                                time: pivotBar.time,
                                price: pivotPrice,
                                type: swingType,
                                swing: 'low'
                            });
                        }

                        pivot.lastLevel = pivot.currentLevel;
                        pivot.currentLevel = pivotPrice;
                        pivot.crossed = false;
                        pivot.time = pivotBar.time;
                        pivot.index = pivotIndex;

                        if (!forEqualHL && !isInternal) {
                            this.trailing.bottom = pivotPrice;
                            this.trailing.bottomTime = pivotBar.time;
                            this.trailing.barTime = pivotBar.time;
                            this.trailing.barIndex = pivotIndex;
                        }

                    } else {
                        const pivot = forEqualHL ? this.equalHigh : (isInternal ? this.internalHigh : this.swingHigh);
                        const pivotPrice = this.highs[pivotIndex];

                        if (forEqualHL && pivot.currentLevel !== null) {
                            if (Math.abs(pivot.currentLevel - pivotPrice) < this.config.equalHLThreshold * atr) {
                                this.equalHighsLows.push({
                                    time1: pivot.time,
                                    time2: pivotBar.time,
                                    price: pivotPrice,
                                    type: 'EQH'
                                });
                            }
                        }

                        if (!forEqualHL && !isInternal) {
                            const swingType = (pivot.lastLevel === null || pivotPrice > pivot.lastLevel) ? 'HH' : 'LH';
                            this.swingPoints.push({
                                time: pivotBar.time,
                                price: pivotPrice,
                                type: swingType,
                                swing: 'high'
                            });
                        }

                        pivot.lastLevel = pivot.currentLevel;
                        pivot.currentLevel = pivotPrice;
                        pivot.crossed = false;
                        pivot.time = pivotBar.time;
                        pivot.index = pivotIndex;

                        if (!forEqualHL && !isInternal) {
                            this.trailing.top = pivotPrice;
                            this.trailing.topTime = pivotBar.time;
                            this.trailing.barTime = pivotBar.time;
                            this.trailing.barIndex = pivotIndex;
                        }
                    }
                }
            }

            _storeOrderBlock(pivot, currentIndex, bias, isInternal) {
                if (pivot.index === null) return;

                let parsedIndex;
                if (bias === BEARISH) {
                    parsedIndex = this._indexOfMax(this.parsedHighs, pivot.index, currentIndex - 1);
                } else {
                    parsedIndex = this._indexOfMin(this.parsedLows, pivot.index, currentIndex - 1);
                }

                if (parsedIndex < 0 || parsedIndex >= this.data.length) return;

                this.orderBlocks.push({
                    time: this.data[parsedIndex].time,
                    high: this.parsedHighs[parsedIndex],
                    low: this.parsedLows[parsedIndex],
                    bias: bias === BULLISH ? 'bullish' : 'bearish',
                    level: isInternal ? 'internal' : 'swing',
                    mitigated: false,
                    mitigatedTime: null
                });

                const maxOB = this.config.maxOrderBlocks * 2;
                if (this.orderBlocks.length > maxOB * 2) {
                    this.orderBlocks = this.orderBlocks.slice(-maxOB * 2);
                }
            }

            _checkOrderBlockMitigation(index) {
                const bar = this.data[index];
                const mitigationHigh = this.config.orderBlockMitigation === 'close' ? bar.close : bar.high;
                const mitigationLow = this.config.orderBlockMitigation === 'close' ? bar.close : bar.low;

                for (const ob of this.orderBlocks) {
                    if (ob.mitigated) continue;

                    if (ob.bias === 'bearish' && mitigationHigh > ob.high) {
                        ob.mitigated = true;
                        ob.mitigatedTime = bar.time;
                    } else if (ob.bias === 'bullish' && mitigationLow < ob.low) {
                        ob.mitigated = true;
                        ob.mitigatedTime = bar.time;
                    }
                }
            }

            _detectFVG(index) {
                if (index < 2) return;

                const bar0 = this.data[index];
                const bar1 = this.data[index - 1];
                const bar2 = this.data[index - 2];

                if (bar0.low > bar2.high && bar1.close > bar2.high) {
                    this.fairValueGaps.push({
                        time: bar1.time,
                        top: bar0.low,
                        bottom: bar2.high,
                        bias: 'bullish',
                        filled: false,
                        filledTime: null
                    });
                }

                if (bar0.high < bar2.low && bar1.close < bar2.low) {
                    this.fairValueGaps.push({
                        time: bar1.time,
                        top: bar2.low,
                        bottom: bar0.high,
                        bias: 'bearish',
                        filled: false,
                        filledTime: null
                    });
                }
            }

            _checkFVGFill(index) {
                const bar = this.data[index];

                for (const fvg of this.fairValueGaps) {
                    if (fvg.filled) continue;

                    if (fvg.bias === 'bullish' && bar.low < fvg.bottom) {
                        fvg.filled = true;
                        fvg.filledTime = bar.time;
                    } else if (fvg.bias === 'bearish' && bar.high > fvg.top) {
                        fvg.filled = true;
                        fvg.filledTime = bar.time;
                    }
                }
            }

            _updateTrailingExtremes(index) {
                const bar = this.data[index];

                if (this.trailing.top === null || bar.high > this.trailing.top) {
                    this.trailing.top = bar.high;
                    this.trailing.topTime = bar.time;
                }

                if (this.trailing.bottom === null || bar.low < this.trailing.bottom) {
                    this.trailing.bottom = bar.low;
                    this.trailing.bottomTime = bar.time;
                }
            }

            _calculatePremiumDiscountZone() {
                if (this.trailing.top === null || this.trailing.bottom === null) return null;

                const range = this.trailing.top - this.trailing.bottom;
                const equilibrium = (this.trailing.top + this.trailing.bottom) / 2;

                return {
                    startTime: this.trailing.barTime,
                    endTime: this.data[this.data.length - 1].time,
                    premiumTop: this.trailing.top,
                    premiumBottom: this.trailing.top - range * 0.05,
                    equilibrium: equilibrium,
                    discountTop: this.trailing.bottom + range * 0.05,
                    discountBottom: this.trailing.bottom
                };
            }

            _calculateStrongWeakLevels() {
                if (this.trailing.top === null || this.trailing.bottom === null) return;

                const isStrongHigh = this.swingTrend === BEARISH;
                const isStrongLow = this.swingTrend === BULLISH;

                if (this.trailing.topTime) {
                    this.strongWeakLevels = this.strongWeakLevels.filter(l => l.type !== 'high');

                    this.strongWeakLevels.push({
                        time: this.trailing.topTime,
                        price: this.trailing.top,
                        strength: isStrongHigh ? 'strong' : 'weak',
                        type: 'high'
                    });
                }

                if (this.trailing.bottomTime) {
                    this.strongWeakLevels = this.strongWeakLevels.filter(l => l.type !== 'low');

                    this.strongWeakLevels.push({
                        time: this.trailing.bottomTime,
                        price: this.trailing.bottom,
                        strength: isStrongLow ? 'strong' : 'weak',
                        type: 'low'
                    });
                }
            }

            calculate(data) {
                this._reset();
                this.data = data;

                if (data.length === 0) return this;

                this.highs = data.map(d => d.high);
                this.lows = data.map(d => d.low);

                this.atrValues = this._calculateATR(data, this.config.atrPeriod);

                const cumTr = [];
                let sumTr = 0;

                for (let i = 0; i < data.length; i++) {
                    const tr = i === 0 ? data[i].high - data[i].low :
                        Math.max(
                            data[i].high - data[i].low,
                            Math.abs(data[i].high - data[i - 1].close),
                            Math.abs(data[i].low - data[i - 1].close)
                        );
                    sumTr += tr;
                    cumTr.push(sumTr / (i + 1));

                    const volatilityMeasure = this.config.orderBlockFilter === 'atr' ?
                        (this.atrValues[i] || cumTr[i]) : cumTr[i];
                    const highVolatilityBar = (data[i].high - data[i].low) >= 2 * volatilityMeasure;

                    this.parsedHighs.push(highVolatilityBar ? data[i].low : data[i].high);
                    this.parsedLows.push(highVolatilityBar ? data[i].high : data[i].low);
                }

                for (let i = 0; i < data.length; i++) {
                    if (this.config.showPremiumDiscount) {
                        this._updateTrailingExtremes(i);
                    }

                    this._processSwingPoints(i, this.config.swingLength, false);
                    this._processSwingPoints(i, this.config.internalLength, true);

                    if (this.config.showEqualHL) {
                        this._processSwingPoints(i, this.config.equalHLLength, false, true);
                    }

                    if (this.config.showInternalStructure) {
                        this._processStructure(i, this.config.internalLength, true);
                    }
                    if (this.config.showSwingStructure) {
                        this._processStructure(i, this.config.swingLength, false);
                    }

                    if (this.config.showOrderBlocks) {
                        this._checkOrderBlockMitigation(i);
                    }

                    if (this.config.showFVG) {
                        this._detectFVG(i);
                        this._checkFVGFill(i);
                    }
                }

                if (this.config.showPremiumDiscount) {
                    const zone = this._calculatePremiumDiscountZone();
                    if (zone) {
                        this.premiumDiscountZones = [zone];
                    }
                    this._calculateStrongWeakLevels();
                }

                return this;
            }

            getStructures(filter = {}) {
                let results = this.structures;
                if (filter.level) results = results.filter(s => s.level === filter.level);
                if (filter.direction) results = results.filter(s => s.direction === filter.direction);
                if (filter.type) results = results.filter(s => s.type === filter.type);
                return results;
            }

            getSwingPoints(filter = {}) {
                let results = this.swingPoints;
                if (filter.type) results = results.filter(s => s.type === filter.type);
                if (filter.swing) results = results.filter(s => s.swing === filter.swing);
                return results;
            }

            getOrderBlocks(filter = {}) {
                let results = this.orderBlocks;
                if (filter.level) results = results.filter(ob => ob.level === filter.level);
                if (filter.bias) results = results.filter(ob => ob.bias === filter.bias);
                if (filter.mitigated !== undefined) results = results.filter(ob => ob.mitigated === filter.mitigated);
                return results;
            }

            getFairValueGaps(filter = {}) {
                let results = this.fairValueGaps;
                if (filter.bias) results = results.filter(fvg => fvg.bias === filter.bias);
                if (filter.filled !== undefined) results = results.filter(fvg => fvg.filled === filter.filled);
                return results;
            }

            getEqualHighsLows(filter = {}) {
                let results = this.equalHighsLows;
                if (filter.type) results = results.filter(eq => eq.type === filter.type);
                return results;
            }

            getPremiumDiscountZone() {
                return this.premiumDiscountZones[0] || null;
            }

            getStrongWeakLevels(filter = {}) {
                let results = this.strongWeakLevels;
                if (filter.type) results = results.filter(l => l.type === filter.type);
                if (filter.strength) results = results.filter(l => l.strength === filter.strength);
                return results;
            }

            getTrend(level = 'swing') {
                const trend = level === 'internal' ? this.internalTrend : this.swingTrend;
                if (trend === BULLISH) return 'bullish';
                if (trend === BEARISH) return 'bearish';
                return 'neutral';
            }

            getAllResults() {
                return {
                    structures: this.structures,
                    swingPoints: this.swingPoints,
                    orderBlocks: this.orderBlocks,
                    fairValueGaps: this.fairValueGaps,
                    equalHighsLows: this.equalHighsLows,
                    premiumDiscountZone: this.getPremiumDiscountZone(),
                    strongWeakLevels: this.strongWeakLevels,
                    swingTrend: this.getTrend('swing'),
                    internalTrend: this.getTrend('internal')
                };
            }
        }

        // ============================================================
        // MAIN APPLICATION
        // ============================================================

        // Generate sample OHLCV data
        function generateSampleData(numBars = 200) {
            const data = [];
            let time = Math.floor(Date.now() / 1000) - numBars * 3600;
            let price = 100;

            for (let i = 0; i < numBars; i++) {
                const volatility = 0.5 + Math.random() * 1.5;
                const trend = Math.sin(i / 30) * 0.3;
                const change = (Math.random() - 0.5 + trend) * volatility;

                const open = price;
                const close = price + change;
                const high = Math.max(open, close) + Math.random() * volatility * 0.5;
                const low = Math.min(open, close) - Math.random() * volatility * 0.5;

                data.push({
                    time: time,
                    open: parseFloat(open.toFixed(2)),
                    high: parseFloat(high.toFixed(2)),
                    low: parseFloat(low.toFixed(2)),
                    close: parseFloat(close.toFixed(2))
                });

                price = close;
                time += 3600;
            }

            return data;
        }

        // Create chart
        const chartContainer = document.getElementById('chart');
        const chart = LightweightCharts.createChart(chartContainer, {
            width: chartContainer.clientWidth,
            height: 500,
            layout: {
                background: { type: 'solid', color: 'transparent' },
                textColor: '#a1a1aa'
            },
            grid: {
                vertLines: { color: 'rgba(255, 255, 255, 0.05)' },
                horzLines: { color: 'rgba(255, 255, 255, 0.05)' }
            },
            crosshair: {
                mode: LightweightCharts.CrosshairMode.Normal
            },
            rightPriceScale: {
                borderColor: 'rgba(255, 255, 255, 0.1)'
            },
            timeScale: {
                borderColor: 'rgba(255, 255, 255, 0.1)',
                timeVisible: true
            }
        });

        // Create candlestick series
        const candlestickSeries = chart.addCandlestickSeries({
            upColor: '#089981',
            downColor: '#F23645',
            borderUpColor: '#089981',
            borderDownColor: '#F23645',
            wickUpColor: '#089981',
            wickDownColor: '#F23645'
        });

        // Generate sample data
        const sampleData = generateSampleData(200);
        candlestickSeries.setData(sampleData);

        // SMC Indicator instance
        let smcIndicator = new SMCIndicator();

        // Colors
        const colors = {
            bullishStructure: '#089981',
            bearishStructure: '#F23645',
            bullishOB: 'rgba(49, 121, 245, 0.3)',
            bearishOB: 'rgba(247, 124, 128, 0.3)',
            bullishFVG: 'rgba(0, 255, 104, 0.3)',
            bearishFVG: 'rgba(255, 0, 8, 0.3)'
        };

        // Update chart function
        function updateChart() {
            const config = {
                swingLength: parseInt(document.getElementById('swingLength').value) || 50,
                internalLength: 5,
                showInternalStructure: true,
                showSwingStructure: true,
                showOrderBlocks: document.getElementById('showOrderBlocks').checked,
                showFVG: document.getElementById('showFVG').checked,
                showEqualHL: document.getElementById('showEqualHL').checked,
                showPremiumDiscount: document.getElementById('showPremiumDiscount').checked
            };

            smcIndicator = new SMCIndicator(config);
            smcIndicator.calculate(sampleData);

            const results = smcIndicator.getAllResults();

            // Build markers
            const markers = [];

            // Add swing points
            if (document.getElementById('showSwingPoints').checked) {
                for (const sp of results.swingPoints) {
                    markers.push({
                        time: sp.time,
                        position: sp.swing === 'high' ? 'aboveBar' : 'belowBar',
                        color: sp.swing === 'high' ? colors.bearishStructure : colors.bullishStructure,
                        shape: sp.swing === 'high' ? 'arrowDown' : 'arrowUp',
                        text: sp.type,
                        size: 1
                    });
                }
            }

            // Add structures
            if (document.getElementById('showStructures').checked) {
                for (const s of results.structures) {
                    markers.push({
                        time: s.time,
                        position: s.direction === 'bullish' ? 'aboveBar' : 'belowBar',
                        color: s.direction === 'bullish' ? colors.bullishStructure : colors.bearishStructure,
                        shape: 'circle',
                        text: s.type,
                        size: 0.5
                    });
                }
            }

            // Add equal highs/lows
            if (document.getElementById('showEqualHL').checked) {
                for (const eq of results.equalHighsLows) {
                    markers.push({
                        time: eq.time2,
                        position: eq.type === 'EQH' ? 'aboveBar' : 'belowBar',
                        color: eq.type === 'EQH' ? colors.bearishStructure : colors.bullishStructure,
                        shape: 'circle',
                        text: eq.type,
                        size: 0.5
                    });
                }
            }

            // Sort and set markers
            markers.sort((a, b) => a.time - b.time);
            candlestickSeries.setMarkers(markers);

            // Update info panel
            updateInfoPanel(results);
        }

        function updateInfoPanel(results) {
            const swingTrendEl = document.getElementById('swingTrend');
            swingTrendEl.textContent = results.swingTrend.toUpperCase();
            swingTrendEl.className = `info-value ${results.swingTrend}`;

            const internalTrendEl = document.getElementById('internalTrend');
            internalTrendEl.textContent = results.internalTrend.toUpperCase();
            internalTrendEl.className = `info-value ${results.internalTrend}`;

            const activeOBs = results.orderBlocks.filter(ob => !ob.mitigated);
            const bullishOBs = activeOBs.filter(ob => ob.bias === 'bullish').length;
            const bearishOBs = activeOBs.filter(ob => ob.bias === 'bearish').length;
            document.getElementById('orderBlockStats').innerHTML = `
                <span class="badge bullish">Bullish: ${bullishOBs}</span>
                <span class="badge bearish">Bearish: ${bearishOBs}</span>
            `;

            const recentStructures = results.structures.slice(-5);
            let structureHTML = '';
            for (const s of recentStructures) {
                structureHTML += `<span class="badge ${s.direction}">${s.type}</span>`;
            }
            document.getElementById('structureStats').innerHTML = structureHTML || '-';
        }

        // Event listeners
        document.getElementById('updateBtn').addEventListener('click', updateChart);

        // Handle resize
        window.addEventListener('resize', () => {
            chart.applyOptions({ width: chartContainer.clientWidth });
        });

        // Initial update
        updateChart();
    </script>
</body>

</html>